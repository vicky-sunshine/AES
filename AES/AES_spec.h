#include "gtest/gtest.h"
#include "AES.hpp"

// Test Constructor
TEST(Key, ROT) {
  uint8_t in[4] = {0x00,0x01,0x02,0x03};
  uint8_t out[4] = {0x01,0x02,0x03,0x00};

  rot_word(in);

  for (int i=0;i<4;i++)
    EXPECT_EQ(in[i],out[i]);
}

TEST(Key, Rcon) {
  uint8_t rc[10] = {
    0x01,0x02,0x04,0x08,
    0x10,0x20,0x40,0x80,
    0x1b,0x36};

  for (int i = 1;i <= 10;i++) {
    EXPECT_EQ(Rcon(i)[0],rc[i-1]);
  }
}

TEST(Key, Process) {
  uint8_t w31[4] = {0x7f,0x8d,0x29,0x2f};

  uint8_t af_rot[4] = {0x8d,0x29,0x2f,0x7f};
  uint8_t af_sub[4] = {0x5d,0xa5,0x15,0xd2};
  uint8_t af_rcon[4] = {0x46,0xa5,0x015,0xd2};

  uint8_t w28[4] = { 0xea,0xd2,0x73,0x21 };
  uint8_t w32[4] = { 0xac,0x77,0x66,0xf3 };

  rot_word(w31);
  for (int i=0;i<4;i++) {
    EXPECT_EQ(w31[i],af_rot[i]);
  }

  sub_word(w31);
  for (int i=0;i<4;i++) {
    EXPECT_EQ(w31[i],af_sub[i]);
  }

  word_add(w31, Rcon(9), w31);
  for (int i=0;i<4;i++) {
    EXPECT_EQ(w31[i],af_rcon[i]);
  }

  for (int i=0;i<4;i++) {
    EXPECT_EQ(w32[i],w28[i]^w31[i]);
  }
}

TEST(KEY, Last_4_word) {
  uint8_t key[16] = {
    0x0f, 0x15, 0x71, 0xc9,
    0x47, 0xd9, 0xe8, 0x59,
    0x0c, 0xb7, 0xad, 0xd6,
    0xaf, 0x7f, 0x67, 0x98};
  uint8_t spec[4] = {
    0x86, 0x26, 0x18, 0x76
  };

  uint8_t result[176];
  key_expansion(key,result);

  for (int i=0;i<4;i++) {
    EXPECT_EQ(result[172+i],spec[i]);
  }

}

TEST(Encrypt, Add_round_key) {
  uint8_t state[16] = {
    0x01, 0x05, 0x01, 0x05,
    0x02, 0x06, 0x02, 0x06,
    0x03, 0x07, 0x03, 0x07,
    0x04, 0x08, 0x04, 0x08};

  uint8_t round_key[16] = {
    0x0f, 0x15, 0x71, 0xc9,
    0x47, 0xd9, 0xe8, 0x59,
    0x0c, 0xb7, 0xad, 0xd6,
    0xaf, 0x7f, 0x67, 0x98};

  uint8_t spec[16] = {
    0x0e, 0x42, 0x0d, 0xaa,
    0x17, 0xdf, 0xb5, 0x79,
    0x72, 0xef, 0xae, 0x60,
    0xcd, 0x51, 0xd2, 0x90
  };
  add_round_key(state, round_key, 0);
  for (int i=0;i<16;i++)
    EXPECT_EQ(state[i],spec[i]);

}

TEST(Encrypt, Sub_bytes) {
  uint8_t state[16] = {
    0x0e, 0x42, 0x0d, 0xaa,
    0x17, 0xdf, 0xb5, 0x79,
    0x72, 0xef, 0xae, 0x60,
    0xcd, 0x51, 0xd2, 0x90
  };
  uint8_t spec[16] = {
    0xab, 0x2c, 0xd7, 0xac,
    0xf0, 0x9e, 0xd5, 0xb6,
    0x40, 0xdf, 0xe4, 0xd0,
    0xbd, 0xd1, 0xb5, 0x60};

  sub_bytes(state);
  for (int i=0;i<16;i++)
    EXPECT_EQ(state[i],spec[i]);
}

TEST(Encrypt, Shift_rows) {
  uint8_t state[16] = {
    0xab, 0x2c, 0xd7, 0xac,
    0xf0, 0x9e, 0xd5, 0xb6,
    0x40, 0xdf, 0xe4, 0xd0,
    0xbd, 0xd1, 0xb5, 0x60};
  uint8_t spec[16] = {
    0xab, 0x2c, 0xd7, 0xac,
    0x9e, 0xd5, 0xb6, 0xf0,
    0xe4, 0xd0, 0x40, 0xdf,
    0x60, 0xbd, 0xd1, 0xb5};

  shift_rows(state);
  for (int i=0;i<16;i++)
    EXPECT_EQ(state[i],spec[i]);
}

TEST(Encrypt, Mix_columns) {
  uint8_t state[16] = {
    0xab, 0x2c, 0xd7, 0xac,
    0x9e, 0xd5, 0xb6, 0xf0,
    0xe4, 0xd0, 0x40, 0xdf,
    0x60, 0xbd, 0xd1, 0xb5};
  uint8_t spec[16] = {
    0x70, 0x51, 0xe5, 0x22,
    0xdb, 0x4b, 0xb1, 0x98,
    0x46, 0x9e, 0x89, 0x3d,
    0x5c, 0x10, 0x2d, 0xb1};
  mix_columns(state);
  for (int i=0;i<16;i++)
    EXPECT_EQ(state[i],spec[i]);
}
